#!/usr/bin/ruby
# -*- coding: utf-8 -*-

#require 'termcolor'
#system('/bin/bash ~/.bash_profile')
#%x['/bin/bash' '/home/pankaj/.bash_profile']
#puts %x[git branch].find{|i| i.match(/^\*/)}

SYMBOL = 
  { 
    :tiger  => "ðŸ˜¸ " , :yinyang => "â˜¯" , :recycle => "â™»" , :hazard => "â˜¢" , :sun     => "â˜€" ,
    :smiley => "â˜»"  , :flag    => "âš‘" , :trust   => "â™º" , :sword  => "âš”" , :parsley => "â˜˜" 
  }

#GIT Status && #GIT Branch
begin
  GIT_STATUS = %x[git status 2> /dev/null]
  GIT_BRANCH = %x[git branch 2> /dev/null].match(/^\*.\w+/)
rescue
  GIT_STATUS = ""
  GIT_BRANCH = "NO-VC"
end

#Out Prompt
prompt ||= []

# Dir.open('.').entries.include?('.git'), this is too long and Dir.exists? not present ruby 1.8.7 / (`ls -a` =~ /[.git]/)   
if Dir.open('.').entries.include?('.git')
  if GIT_STATUS =~ /working directory clean/
    if GIT_STATUS =~ /branch is ahead/
      prompt << "\e[1;41m#{SYMBOL[:tiger]}" #+ "{git_status.to_a[1].split(/*..commits/)}"
    else
      prompt << SYMBOL[:yinyang]
    end
    
  elsif GIT_STATUS =~ /Changes to be committed/
    prompt << SYMBOL[:recycle]
  elsif GIT_STATUS =~ /Changes not staged for commit:/ 
    prompt << SYMBOL[:hazard]
  elsif GIT_STATUS =~ /Untracked files/
    prompt << SYMBOL[:sun]
  end
  
  if GIT_BRANCH != ""
    prompt << GIT_BRANCH.to_s
  end
else
  prompt << "NO-VC"
end

puts prompt.to_s
